"use strict";
var tslib_1 = require("tslib");
var pg_1 = require("pg");
var pg_connection_string_1 = require("pg-connection-string");
var events_1 = require("events");
var chalk = require("chalk");
var createPostGraphQLSchema_1 = require("./schema/createPostGraphQLSchema");
var createPostGraphQLHttpRequestHandler_1 = require("./http/createPostGraphQLHttpRequestHandler");
var exportPostGraphQLSchema_1 = require("./schema/exportPostGraphQLSchema");
var watchPgSchemas_1 = require("./watch/watchPgSchemas");
function postgraphql(poolOrConfig, schemaOrOptions, maybeOptions) {
    var schema;
    var options;
    // If the second argument is undefined, use defaults for both `schema` and
    // `options`.
    if (typeof schemaOrOptions === 'undefined') {
        schema = 'public';
        options = {};
    }
    else if (typeof schemaOrOptions === 'string' || Array.isArray(schemaOrOptions)) {
        schema = schemaOrOptions;
        options = maybeOptions || {};
    }
    else {
        schema = 'public';
        options = schemaOrOptions;
    }
    // Creates the Postgres schemas array.
    var pgSchemas = Array.isArray(schema) ? schema : [schema];
    // Do some things with `poolOrConfig` so that in the end, we actually get a
    // Postgres pool.
    var pgPool = 
    // If it is already a `Pool`, just use it.
    poolOrConfig instanceof pg_1.Pool
        ? poolOrConfig
        : new pg_1.Pool(typeof poolOrConfig === 'string'
            ? pg_connection_string_1.parse(poolOrConfig)
            : poolOrConfig || {});
    // Creates a promise which will resolve to a GraphQL schema. Connects a
    // client from our pool to introspect the database.
    //
    // This is not a constant because when we are in watch mode, we want to swap
    // out the `gqlSchema`.
    var gqlSchema = createGqlSchema();
    var _emitter = new events_1.EventEmitter();
    // If the user wants us to watch the schema, execute the following:
    if (options.watchPg) {
        watchPgSchemas_1.default({
            pgPool: pgPool,
            pgSchemas: pgSchemas,
            onChange: function (_a) {
                var commands = _a.commands;
                // tslint:disable-next-line no-console
                console.log("Rebuilding PostGraphQL API after Postgres command(s): \uFE0F" + commands.map(function (command) { return chalk.bold.cyan(command); }).join(', '));
                _emitter.emit('schemas:changed');
                // Actually restart the GraphQL schema by creating a new one. Note that
                // `createGqlSchema` returns a promise and we aren’t ‘await’ing it.
                gqlSchema = createGqlSchema();
            },
        })
            .catch(function (error) {
            // tslint:disable-next-line no-console
            console.error(error.stack + "\n");
            process.exit(1);
        });
    }
    // Finally create our Http request handler using our options, the Postgres
    // pool, and GraphQL schema. Return the final result.
    return createPostGraphQLHttpRequestHandler_1.default(Object.assign({}, options, {
        getGqlSchema: function () { return gqlSchema; },
        pgPool: pgPool,
        _emitter: _emitter,
    }));
    /**
     * Creates a GraphQL schema by connecting a client from our pool which will
     * be used to introspect our Postgres database. If this function fails, we
     * will log the error and exit the process.
     *
     * This may only be executed once, at startup. However, if we are in watch
     * mode this will be updated whenever there is a change in our schema.
     */
    function createGqlSchema() {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var pgClient, newGqlSchema, error_1;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 3, , 4]);
                        return [4 /*yield*/, pgPool.connect()];
                    case 1:
                        pgClient = _a.sent();
                        return [4 /*yield*/, createPostGraphQLSchema_1.default(pgClient, pgSchemas, options)];
                    case 2:
                        newGqlSchema = _a.sent();
                        exportGqlSchema(newGqlSchema);
                        // If no release function exists, don’t release. This is just for tests.
                        if (pgClient && pgClient.release)
                            pgClient.release();
                        return [2 /*return*/, newGqlSchema];
                    case 3:
                        error_1 = _a.sent();
                        return [2 /*return*/, handleFatalError(error_1)];
                    case 4: return [2 /*return*/];
                }
            });
        });
    }
    function exportGqlSchema(newGqlSchema) {
        return tslib_1.__awaiter(this, void 0, void 0, function () {
            var error_2;
            return tslib_1.__generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, exportPostGraphQLSchema_1.default(newGqlSchema, options)];
                    case 1:
                        _a.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        error_2 = _a.sent();
                        handleFatalError(error_2);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    }
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = postgraphql;
function handleFatalError(error) {
    // tslint:disable-next-line no-console
    console.error(error.stack + "\n");
    process.exit(1);
    // `process.exit` will mean all code below it will never get called.
    // However, we need to return a value with type `never` here for
    // TypeScript.
    return null;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9zdGdyYXBocWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvcG9zdGdyYXBocWwvcG9zdGdyYXBocWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSx5QkFBcUM7QUFDckMsNkRBQXVFO0FBRXZFLGlDQUFxQztBQUNyQyw2QkFBK0I7QUFDL0IsNEVBQXNFO0FBQ3RFLGtHQUFvSDtBQUNwSCw0RUFBc0U7QUFDdEUseURBQW1EO0FBOEJuRCxxQkFDRSxZQUF5QyxFQUN6QyxlQUE2RCxFQUM3RCxZQUFpQztJQUVqQyxJQUFJLE1BQThCLENBQUE7SUFDbEMsSUFBSSxPQUEyQixDQUFBO0lBRS9CLDBFQUEwRTtJQUMxRSxhQUFhO0lBQ2IsRUFBRSxDQUFDLENBQUMsT0FBTyxlQUFlLEtBQUssV0FBVyxDQUFDLENBQUMsQ0FBQztRQUMzQyxNQUFNLEdBQUcsUUFBUSxDQUFBO1FBQ2pCLE9BQU8sR0FBRyxFQUFFLENBQUE7SUFDZCxDQUFDO0lBSUQsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLE9BQU8sZUFBZSxLQUFLLFFBQVEsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLGVBQWUsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUMvRSxNQUFNLEdBQUcsZUFBZSxDQUFBO1FBQ3hCLE9BQU8sR0FBRyxZQUFZLElBQUksRUFBRSxDQUFBO0lBQzlCLENBQUM7SUFHRCxJQUFJLENBQUMsQ0FBQztRQUNKLE1BQU0sR0FBRyxRQUFRLENBQUE7UUFDakIsT0FBTyxHQUFHLGVBQWUsQ0FBQTtJQUMzQixDQUFDO0lBRUQsc0NBQXNDO0lBQ3RDLElBQU0sU0FBUyxHQUFrQixLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBRTFFLDJFQUEyRTtJQUMzRSxpQkFBaUI7SUFDakIsSUFBTSxNQUFNO0lBQ1YsMENBQTBDO0lBQzFDLFlBQVksWUFBWSxTQUFJO1VBQ3hCLFlBQVk7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